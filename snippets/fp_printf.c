// This is the floating point formatter extracted from Walter Bright's
// Zortech-C compiler (now called "Digital Mars C").  We use this because
// it is much smaller than the newlib one.

//_ fmt.c
// Copyright (C) 1986-2009 by Digital Mars
// All Rights Reserved
// http://www.digitalmars.com

/*
All the files in this package that are copyrighted by:

    Walter Bright
    Digital Mars
    Symantec
    SLR Systems
    D Language Foundation

are licensed by the Boost Software License:

http://www.boost.org/users/license.html

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include <math.h>
#include <string.h>

#define LDBL_DIG 18

#define DIGMAX	(LDBL_DIG*2)	/* max # of digits in string		*/
				/* (*2 is a good fudge factor)		*/

#define ECVT	0
#define FCVT	1

/********************* printf interface ********************/

char *__floatcvt(int cnvflag, char *digstr, double val, int ndig, int *pdecpt, int *psign);
static void __doexponent(char **ps, int exp, int flag);
static char *__trim0(char *s);

/* Flags for flag word (keep in sync with ecvt.c)	*/
#define	FLplus		2
#define	FLspc		4
#define FLhash		8
#define FL0pad		0x40
#define FLprec		0x80
#define FLgformat	0x1000		/* g floating point format	*/

char *__dosign(int sign, int flags)
{
	return	(sign)		 ? "-" :
		(flags & FLplus) ? "+" :
		(flags & FLspc)	 ? " " :
				   "";
}

/***********************************
 * Do floating point formatting.
 */

char  *__floatfmt(int c, int flags, int precision, double *pdval, char *buf, int *psl, int width)
{
    char *p;
    int fpd;			/* classification of double value	*/
    int decpt;			/* exponent (base 10) for floats	*/
    int sign;
    char  *prefix;
    int sl;			/* length of formatted string s		*/
    char digstr[LDBL_DIG*2 + 2];
    char *sbuf;
    double dval;
    int bufmax = *psl;

    if (!(flags & FLprec))	/* if no precision	*/
	precision = 6;		/* default precision	*/

    dval = *pdval;
    fpd = fpclassify(dval);
    if (fpd <= FP_INFINITE)	/* if nan or infinity	*/
    {
	static char fptab[][5] =
	{ "nans","nan","inf" };
	static char fptablen[] = { 4,3,3 };

	/* '#' and '0' flags have no effect	*/
	flags &= ~(FL0pad | FLhash);
	prefix = __dosign(signbit(dval),flags);

	*(unsigned long *)buf = *(unsigned long *)fptab[fpd];
	if (!(c & 0x20))	/* if c is upper case	*/
	    /* Convert to upper case */
	    *(unsigned long *)buf &= ~0x20202020;
	sl = fptablen[fpd];	/* length of string	*/
    }
    else
    {
	switch (c)
	{
	    case 'f':
	    case 'F':
	    fformat:
		p = __floatcvt(FCVT,digstr,dval,precision,&decpt,&sign);
		prefix = __dosign(sign,flags);
		sbuf = &buf[0];
		if (decpt <= 0)
		    *sbuf++ = '0';	/* 1 digit before dec point */
		while (decpt > 0)
		{
		    if (sbuf >= &buf[bufmax - 1])
			goto Lerror;
		    *sbuf++ = *p ? *p++ : '0';
		    decpt--;
		}
		if (precision > 0 || flags & FLhash)
		{
		    *sbuf++ = '.';	/* . */
		    while (decpt < 0 && precision > 0)
		    {
			if (sbuf >= &buf[bufmax])
			    goto Lerror;
			*sbuf++ = '0';
			decpt++;
			precision--;
		    }

		    if (precision > &buf[bufmax] - sbuf)
			goto Lerror;
		    for (; precision; precision--)
		    {
			*sbuf++ = *p ? *p++ : '0';
		    }

		    /* remove trailing 0s	*/
		    if ((flags & (FLgformat | FLhash)) == FLgformat)
			sbuf = __trim0(sbuf);
		}
		sl = sbuf - &buf[0];	/* length of string	*/
		break;
	    case 'e':
	    case 'E':
		p = __floatcvt(ECVT,digstr,dval,precision + 1,&decpt,&sign);
	    eformat:
		prefix = __dosign(sign,flags);
		buf[0] = *p;
		sbuf = &buf[1];
		if (flags & FLhash ||
		    (precision > 0 &&
		    (!(flags & FLgformat) || precision != 1 || width))
		   )
		{	int n;

			buf[1] = '.';	/* . */
			n = bufmax - 5 - 2;
			if (n < precision)
			    goto Lerror;

			p++;
			sbuf++;
			for (n = 0; n < precision; n++)
			{
			    *sbuf++ = *p ? *p++ : '0';
			}

			/* remove trailing 0s	*/
			if ((flags & (FLgformat | FLhash)) == FLgformat)
			    sbuf = __trim0(sbuf);
		}
		if (precision || (flags & FLprec && !(flags & FLgformat)))
		{   *sbuf++ = c;
		    if (dval)		/* avoid 0.00e-01	*/
			decpt--;
		    __doexponent(&sbuf,decpt,1);
		}
		sl = sbuf - &buf[0];	/* length of string	*/
		break;
	    case 'G':
	    case 'g':
		flags |= FLgformat;
		if (precision == 0)
		    precision = 1;
		p = __floatcvt(ECVT,digstr,dval,precision,&decpt,&sign);
		/* decpt-1 is the exponent	*/
		if (decpt < -3 || decpt > precision)
		{			/* use e format		*/
		    if (precision > 1)
			precision--;
		    c -= 'g' - 'e';
		    goto eformat;
		}
		else
		{   /* Convert precision to digits *after* dot	*/
		    precision -= decpt;	/* precision is >= 0	*/
		    goto fformat;
		}

	    case 'a':
	    case 'A':

		decpt = ((((unsigned short *)&dval)[3] & 0x7FF0) >> 4) - 0x3FF;
		{   unsigned long val[2];
		    unsigned long val2[2];
		    int i;

		    val[0] = ((unsigned long *)&dval)[0];
		    val[1] = ((unsigned long *)&dval)[1];

		    // Left justify
		    if (dval)
		    {	val[1] |= 0x100000L;
			val[1] <<= 11;
			val[1] |= val[0] >> 5;
			val[0] <<= 11;
		    }

		Lagain:
		    val2[0] = val[0];
		    val2[1] = val[1];
		    p = digstr;
		    if ((long)val[1] < 0)
			*p = '1';
		    else
			*p = '0';
		    p++;
		    val[1] <<= 1;
		    if ((long)val[0] < 0)
			val[1] |= 1;
		    val[0] <<= 1;

		    if (!(flags & FLprec))
			precision = 1000;	// number arbitrarilly larger
						// than nibbles in mantissa

		    for (i = 0; i < precision; i++)
		    {
			unsigned nibble;

			if (!(flags & FLprec) && !(val[1] | val[0]))	// don't leave trailing 0's
			{   precision = i;
			    break;
			}
			nibble = (val[1] >> 28) & 0x0F;
			if (nibble < 10)
			    *p = '0' + nibble;
			else if (c == 'a')
			    *p = 'a' + nibble - 10;
			else
			    *p = 'A' + nibble - 10;
			p++;
			val[1] <<= 4;
			val[1] |= val[0] >> 28;
			val[0] <<= 4;
			if (p - digstr == sizeof(digstr)/sizeof(digstr[0]) - 1)
			    break;
		    }
		    *p = 0;

		    // Round up if (guard && (odd || sticky))
		    if ((long)val[1] < 0 && (p[-1] & 1 || (val[1] << 1) || val[0]))
		    {
			if (i >= 8)
			{   if ((long)val2[0] < 0)
			    {	val2[0] += 0x80000000L >> ((i - 8) * 4);
				if ((long)val2[0] >= 0)
				    val2[1]++;
			    }
			    else
				val2[0] += 0x80000000L >> ((i - 8) * 4);
			}
			else
			    val2[1] += 0x80000000L >> (i * 4);
			if ((long)val2[1] >= 0)
			{
			    val2[0] >>= 1;
			    if (val2[1] & 1)
				val2[0] |= 0x80000000L;
			    val2[1] >>= 1;
			    val2[1] |= 0x80000000L;
			    decpt++;
			}
			val[0] = val2[0];
			val[1] = val2[1];
			goto Lagain;
		    }
		}
		p = digstr;
		sign = 0;
		//if (dval < 0)
		if (signbit(dval))
		    sign = 1;

		prefix = __dosign(sign,flags);
		buf[0] = '0';
		buf[1] = 'X' | (c & 0x20);	// 'X' or 'x'
		buf[2] = *p;
		sbuf = &buf[3];
		if (flags & FLhash || precision > 0 || !dval)
		{	int n;

			buf[3] = '.';	/* . */
			n = bufmax - 7 - 4;	// 4 for 0xh., 7 for p+ddddd
			if (n < precision)
			    goto Lerror;

			p++;
			sbuf++;
			for (n = 0; n < precision; n++)
			{
			    *sbuf++ = *p ? *p++ : '0';
			}
		}
		//if (precision || flags & FLprec)
		{   *sbuf++ = 'P' | (c & 0x20);		// 'P' or 'p'
		    if (!dval)
			decpt = 0;	// exponent for 0 is 0
		    __doexponent(&sbuf,decpt,0);
		}
		sl = sbuf - &buf[0];	/* length of string	*/
		break;
	}
    }
    *psl = sl;
    return prefix;

Lerror:
    *psl = -1;
    return prefix;
}

/**************************
 * Add exponent to string s in form +-nn.
 * At least 2 digits.
 */

static void   __doexponent(char **ps, int exp, int flag)
{	register char *s = *ps;

	*s++ = (exp < 0) ? ((exp = -exp),'-') : '+';

	if (exp >= 10000)
	{
	    *s++ = exp / 10000 + '0';
	    exp %= 10000;
	    goto L2;
	}
	else if (exp >= 1000)
	{
	 L2:
	    *s++ = exp / 1000 + '0';
	    exp %= 1000;
	    goto L1;
	}
	else if (exp >= 100)
	{
	 L1:
	    *s++ = exp / 100 + '0';
	    exp %= 100;
	    goto L0;
	}
	// Microsoft uses a minimum of 3 digits.
	// We do 2 for ANSI C99 compatibility.
	else if (flag || exp >= 10)
	{
	 L0:
	    *s++ = exp / 10 + '0';
	    exp %= 10;
	}
	*s++ = exp + '0';
	*ps = s;
}

/**************************
 * Trim trailing 0s and decimal point from string.
 */

static char *__trim0(char *s)
{
	while (*(s-1) == '0')
		s--;
	if (*(s-1) == '.')		/* . */
		s--;
	return s;
}

static double negtab[] =
{
	1e-256, 1e-128, 1e-64, 1e-32, 1e-16, 1e-8, 1e-4, 1e-2, 1e-1, 1.0
};

static double postab[] =
{
	1e+256, 1e+128, 1e+64, 1e+32, 1e+16, 1e+8, 1e+4, 1e+2, 1e+1
};

/*************************
 * Convert double val to a string of
 * decimal digits.
 *	if (cnvflag == ECVT)
 *		ndig = # of digits in resulting string past the decimal point
 *	else
 *		ndig = # of digits in resulting string
 * 	digstr[LDBL_DIG * 2 + 2]
 * Returns:
 *	*pdecpt = position of decimal point from left of first digit
 *	*psign  = nonzero if value was negative
 * BUGS:
 *	This routine will hang if it is passed a NAN or INFINITY.
 */

char * __floatcvt(int cnvflag, char *digstr, double val, int ndig, int *pdecpt, int *psign)
{
	int decpt,pow,i;
	int nsig;
	int sig;
	char c;

	if (signbit(val))
	{
	    *psign = 1;
	    val = -val;
	}
	else
	    *psign = 0;
	ndig = (ndig < 0) ? 0
			  : (ndig < DIGMAX) ? ndig
					    : DIGMAX;
	if (val == 0)
	{
		memset(digstr,'0',ndig);
		decpt = 0;
	}
	else
	{	/* Adjust things so that 1 <= val < 10	*/
		decpt = 1;
		pow = 256;
		i = 0;
		while (val < 1)
		{	while (val < negtab[i + 1])
			{	val *= postab[i];
				decpt -= pow;
			}
			pow >>= 1;
			i++;
		}
		pow = 256;
		i = 0;
		while (val >= 10)
		{	while (val >= postab[i])
			{	val *= negtab[i];
				decpt += pow;
			}
			pow >>= 1;
			i++;
		}

		if (cnvflag == FCVT && decpt > 0)
		{	ndig += decpt;
			if (ndig > DIGMAX)
			    ndig = DIGMAX;
		}

		/* Pick off digits 1 by 1 and stuff into digstr[]	*/
		/* Do 1 extra digit for rounding purposes		*/
		nsig = 0;
		sig = 0;
		for (i = 0; i <= ndig; i++)
		{	int n;

			if (nsig > LDBL_DIG+1)
			    c = '0';
			else
			{
			    n = val;
			    c = n + '0';
			    val = (val - n) * 10;	/* get next digit */
			    if (n)
				sig = 1;
			    nsig += sig;
			}
			digstr[i] = c;
		}
		if (c >= '5')		/* if we need to round		*/
		{	--i;
			while (1)
			{
				c = '0';
				if (i == 0)		/* if at start	*/
				{	ndig += cnvflag;
					decpt++;	/* shift dec pnt */
							/* "100000..."	*/
					break;
				}
				digstr[i] = '0';
				--i;
				c = digstr[i];
				if (c != '9')
					break;
			}
			digstr[i] = c + 1;
		} /* if */
	} /* else */
	*pdecpt = decpt;
	digstr[ndig] = 0;		/* terminate string		*/
	return digstr;
}

//_ strtod.c
// Copyright (C) 1985-2001 by Digital Mars
// All Rights Reserved
#if 1

#include	<stdlib.h>
#include	<ctype.h>
#include	<float.h>
#include	<string.h>
#include	<math.h>
#include	<errno.h>

/*************************
 * Convert string to double.
 * Terminates on first unrecognized character.
 */

#define NOHEX 1

double wbstrtod(const char *p,char **endp)
{
	double dval;
	int exp;
	unsigned long msdec,lsdec;
	unsigned long msscale;
	char hex,dot,sign,subject;
	int pow;
	const char *pinit = p;
	static char infinity[] = "infinity";
	static char nans[] = "nans";
	unsigned int old_cw;
	unsigned int old_status;
	
	while (isspace(*p))
	    p++;
	sign = 0;			/* indicating +			*/
	switch (*p)
	{	case '-':
			sign++;
			/* FALL-THROUGH */
		case '+':
			p++;
	}
	subject = 0;
	dval = 0.0;
	dot = 0;			/* if decimal point has been seen */
	exp = 0;
	hex = 0;
	msdec = lsdec = 0;
	msscale = 1;

	switch (*p)
	{   case 'i':
	    case 'I':
		if (memicmp(p,infinity,8) == 0)
		{   p += 8;
		    goto L4;
		}
		if (memicmp(p,infinity,3) == 0)		/* is it "inf"?	*/
		{   p += 3;
		L4:
		    dval = HUGE_VAL;
		    subject = 1;
		    goto L3;
		}
		break;
	    case 'n':
	    case 'N':
		if (memicmp(p,nans,3) == 0)		/* "nan"?	*/
		{   p += 3;
		    dval = NAN;
		L5:
		    if (*p == '(')		/* if (n-char-sequence)	*/
			goto L1;		/* invalid input	*/
		    subject = 1;
		    goto L3;
		}
	}

#ifndef NOHEX
	if (*p == '0' && (p[1] == 'x' || p[1] == 'X'))
	{   p += 2;
	    hex++;
	    while (1)
	    {	int i = *p;

		while (isxdigit(i))
		{
		    subject = 1;	/* must have at least 1 digit	*/
		    i = isalpha(i) ? ((i & ~0x20) - ('A' - 10)) : i - '0';
		    if (msdec < (0xFFFFFFFF-16)/16)
			msdec = msdec * 16 + i;
		    else if (msscale < (0xFFFFFFFF-16)/16)
		    {	lsdec = lsdec * 16 + i;
			msscale *= 16;
		    }
		    else
			exp++;
		    exp -= dot;
		    i = *++p;
		}
		if (i == '.' && !dot)
		{	p++;
			dot++;
		}
		else
			break;
	    }
	    exp *= 4;
	    if (!subject)		/* if error (no digits seen)	*/
		goto L1;
	    if (*p == 'p' || *p == 'P')
		goto L2;
	    else
	    {	subject = 0;
		goto L1;		/* error, exponent is req'd	*/
	    }
	}
	else
#endif
	{
	    while (1)
	    {	int i = *p;

		while (isdigit(i))
		{
		    subject = 1;	/* must have at least 1 digit	*/
		    if (msdec < (0x7FFFFFFF-10)/10)
			msdec = msdec * 10 + (i - '0');
		    else if (msscale < (0x7FFFFFFF-10)/10)
		    {	lsdec = lsdec * 10 + (i - '0');
			msscale *= 10;
		    }
		    else
			exp++;
		    exp -= dot;
		    i = *++p;
		}
		if (i == '.' && !dot)
		{	p++;
			dot++;
		}
		else
			break;
	    }
	}
	if (!subject)			/* if error (no digits seen)	*/
	    goto L1;			/* return 0.0			*/
	if (*p == 'e' || *p == 'E')
	{
	    char sexp;
	    int e;
	L2:
	    sexp = 0;
	    switch (*++p)
	    {	case '-':
			sexp++;
			/* FALL-THROUGH */
		case '+':
			p++;
	    }
	    subject = 0;
	    e = 0;
	    while (isdigit(*p))
	    {
		if (e < DBL_MAX_EXP*2)		/* prevent integer overflow */
		    e = e * 10 + *p - '0';
		p++;
		subject = 1;
	    }
	    exp += (sexp) ? -e : e;
	    if (!subject)		/* if no digits in exponent	*/
		goto L1;		/* return 0.0			*/
	}

	dval = msdec;
	if (msscale != 1)		/* if stuff was accumulated in lsdec */
	    dval = dval * msscale + lsdec;

	if (dval)
	{   unsigned u;

#ifndef NOHEX
	    if (hex)
	    {
		/* Exponent is power of 2, not power of 10	*/
		dval = ldexp(dval,exp);
		exp = 0;
	    }
#endif

	    u = 0;
	    pow = 256;

	    while (exp > 0)
	    {	while (exp >= pow)
		{	dval *= postab[u];
			exp -= pow;
		}
		pow >>= 1;
		u++;
	    }
	    while (exp < 0)
	    {	while (exp <= -pow)
		{	dval *= negtab[u];
			if (dval == 0)
				errno = ERANGE;
			exp += pow;
		}
		pow >>= 1;
		u++;
	    }
	        
	    /* if overflow occurred		*/
	    if (dval == HUGE_VAL)
		errno = ERANGE;		/* range error			*/
	}

    L1:
	if (endp)
	{   if (subject == 0)		/* if subject string was empty	*/
		p = pinit;		/* indicate no conversion done	*/
	    *endp = (void *) p;
	}
    L3:
    
    return (sign) ? -dval : dval;
}
#endif
